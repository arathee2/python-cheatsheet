------------------------------------------------------------------------------
Concepts
------------------------------------------------------------------------------
- A class has three kinds of attributes (fields and methods): instance and class. Each of these have their own namespaces.
- Attributes can be created inside as well as outside the class.
- Attribute assignment (object.attr = ...) assigns the attribute to that namespace i.e either instance or class depending on what object refers to.
- Attribute reference (object.attr) kicks off inheritence search in the following order: bottom to top (inheritence hierarchy), left-to-right (multiple superclasses).
- When interpreter reacher the class statement, it creates the class object and runs all its statements that result in creation of top-level attributes (fields and methods).
- Attributes created inside methods only spring into existence when methods are run.
- ClassName.method(instance) and instance.method() are equivalent.

# Inheritence
- Attribute reference (object.attr) kicks off inheritence search in the following order: bottom to top (instance -> class -> super class), left-to-right (multiple superclasses).
- object.__dict__ contains the attribute names and values where object could be a class or an instance. object.__dict__['attr'] could also be used for assignment or reference.
- instance.__dict__['attribute'] does not kick off inheritence and accesses the attribute from the class it was created from.
- Supports multiple inheritence.
- Supports method overriding.
- Supports abstract classes.

# Polymorphism
- Supports operator overloading.

# Encapsulation
- There is no notion of private or protected attributes in Python OOP.
- All attributes are public by default.

------------------------------------------------------------------------------
Syntax
------------------------------------------------------------------------------
class ClassName(SuperClassA, SuperClassB):        # class --> ClassName object; this statement runs all statements within class body resulting in creation of class attributes: static names and method names
    attrA = ...                                   # class attribute (static): shared across all instances; access these using `ClassName.attrA`
    self.attrA = ...                              # instance attribute; access these using `instance.attrA`
    
    def methodName(self, arg):                    # an attribute similar to attrA; a method; could be accessed by `ClassName.methodName` or called by `ClassName.methodName(arg)`
        SuperClassA.methodName(self, arg)         # calls SuperClassA's methodName; without this call
        print(self.attrA)
        print(arg)

ClassName.attrB = ...                             # possible but stupid; class attribute: instances will be able to access this attribute
ClassName.anotherMethod = someMethod(obj)         # same as above but for methods (remember, methods are attributes); this is why methods need `self` argument (`obj` in this case)
instance = ClassName()
instance.attrC = ...                              # possible but stupid; instance attribute: no other instances can access this attribute
instance.methodName(0)                            # if self.attrA was not assigned (e.g. if assignment was in another function) this method call would be an error
instance.__dict__                                 # attributes and values of this class (excludes superclass attributes)
instance.__class__                                # has in turn another attributes such as __name__ and __bases__
instance.__bases__                                # contains names of all super classes

# abstract class
from abc import ABCMeta, abstractmethod
class AbstractClass(metaclass=ABCMeta):
    @abstractmethod
    def method():
        pass
abstract = AbstractClass()                        # error! classes with abstract method cannot be instantiated; define a subclass that defiend this method and instantiate that subclass

# operator overloading
class Person:
      def __init__(self, name, age):              #  constructor
          self.name = name
          self.age = age

      def __del__(self):                          # destructor
          pass

      def __add__(self, other):                   # invoked when `instance + other`; could return any type of result
          pass

      def __sub__(self, other):                   # invoked when `instance - other`
          pass

      def __radd(self, other):                    # invoked when `other + instance` 
          pass

      def __iadd__(self, other):                  # invoked when `instance += other`; this is an optional method (for efficient in-place addition) because fallback is __add__
          pass

      def __call__(self, *args, **kwargs):        # invoked when `object(*args, **kwargs)` i.e. when object is called. Arguments could be arbitrarily defined
          pass
      
      def __getitem__(self, index):               # for index and slice reference expressions; also used as fallback iterator by repeatedly indexing from 0 until StopIteration occurs
          if isinstance(index, int):              # when instance[i] is invoked, i is passed as the second argument
              pass
          elif isinstance(slice):                 # when instance[i:j:k] is invoked, slice(i, j, k) is passed as the second argument
              pass

      def __setitem__(self, index, value):        # for index and slice assignments
          pass

      def __iter__(self):                         # returns iterator object upon running `iter(object)`; iterator object has to have the __next__() method; return self and implement __next__ in the same class for single iteration scan; return an iterable object that is implemented in a different class with __next__ to support multiple scans
          pass

      def __next__(self):                         # invoked when `next(object)` or `for i in object:` is run; returns the next item in sequence; usually implemented in iterator class
          pass

      def __contains__(self, value):              # invoked when doing memberships tests such as x in y; return True is class contains value; fallback methods in case this is absent are __iter__ and __getitem__
          pass

      def __getattr__(self, attrname):            # invoked when `object.attrname` or `getattr(object, attrname)` i.e. attribute reference - for an undefined attribute; can be used to emulate attribute privacy
          if attrname == 'age'
              return 40
          else:
              raise AttributeError(attrname)

      def __getattribute__(self, attrname):       # invoked when `object.attrname` i.e. attribute reference - for all attributes, not just undefiend ones; can be used to emulate attribute privacy
          pass
          
      def __setattr__(self, attrname, value):     # invoked when `object.attrname = value` or `setattr(object, attrname, value)` i.e. attribute assignment for all attributes, not just undefined ones; can be used to emulate attribute privacy
          if attrname == 'age':
              self.__dict__[attrname] = value     # don't do self.attrname = value because that calls __setattr__ again ending up in an infinite loop
          else:
              raise AttributeError(attrname,
              'cannot be assigned')

      def __delattr(self, attrname):              # invoked when `del object.attrname`
          if attrname in self__dict__:
             del self.__dict__[attrname]
          else:
          raise AttributeError(attrname,
          ' does not exist!')

      def __lt__(self, other):                   # invoked when `object < other`; all comparison operators have their correponding methods
          return self.data < other
      
      def __index__(self):                        # invoked when bin(instance), oct(instance) and hex(instance) is encountered
          return hash

      def set_name(name):
          self.name = name
          
      def get_name(self):
          return self.name

      def __str__(self):                          # returns string representation of object when `print(object)` and `str(object)`
          return string_representation

      def __repr__(self):                         # returns a string when `repr(object)` that shows how the object was constructed; used as fallback when __str__ is not present
          return repr_representation

      def _method_name(self):                     # method name starting with _ are meant to be used within this class; overriding these is possible; use __ to avoid overriding
          ...

      def __method_name(self):                    # this method name is expanded to Person.__method_name(self) to avoid name clash when overriding this method
          ...

class Manager(Person):
      def get_name():
          Person.get_name(self, 'Mgr ' + name)    # calling parent's method

manager = Manager('John', 40)

