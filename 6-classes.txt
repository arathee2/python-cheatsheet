------------------------------------------------------------------------------
Concepts
------------------------------------------------------------------------------
- A class has three kinds of attributes (fields and methods): instance and class. Each of these have their own namespaces.
- Attributes can be created inside as well as outside the class.
- Attribute assignment (object.attr = ...) assigns the attribute to that namespace i.e either instance or class depending on what object refers to.
- Attribute reference (object.attr) kicks off inheritence search in the following order: bottom to top (inheritence hierarchy), left-to-right (multiple superclasses).
- When interpreter reacher the class statement, it creates the class object and runs all its statements that result in creation of top-level attributes (fields and methods).
- Attributes created inside methods only spring into existence when methods are run.
- ClassName.method(instance) and instance.method() are equivalent.

# Inheritence
- Attribute reference (object.attr) kicks off inheritence search in the following order: bottom to top (instance -> class -> super class), left-to-right (multiple superclasses).
- object.__dict__ contains the attribute names and values where object could be a class or an instance. object.__dict__['attr'] could also be used for assignment or reference.
- instance.__dict__['attribute'] does not kick off inheritence and accesses the attribute from the class it was created from.
- Supports multiple inheritence.
- Supports method overriding.
- Supports abstract classes.

# Polymorphism
- Supports operator overloading.

# Encapsulation
- There is no notion of private or protected attributes in Python OOP.
- All attributes are public by default.

------------------------------------------------------------------------------
Syntax
------------------------------------------------------------------------------
class ClassName(SuperClassA, SuperClassB):        # class --> ClassName object; this statement runs all statements within class body resulting in creation of class attributes: static names and method names
    attrA = ...                                   # class attribute (static): shared across all instances; access these using `ClassName.attrA`
    self.attrA = ...                              # instance attribute; access these using `instance.attrA`
    
    def methodName(self, arg):                    # an attribute similar to attrA; a method; could be accessed by `ClassName.methodName` or called by `ClassName.methodName(arg)`
        SuperClassA.methodName(self, arg)         # calls SuperClassA's methodName; without this call
        print(self.attrA)
        print(arg)

ClassName.attrB = ...                             # possible but stupid; class attribute: instances will be able to access this attribute
ClassName.anotherMethod = someMethod(obj)         # same as above but for methods (remember, methods are attributes); this is why methods need `self` argument (`obj` in this case)
instance = ClassName()
instance.attrC = ...                              # possible but stupid; instance attribute: no other instances can access this attribute
instance.methodName(0)                            # if self.attrA was not assigned (e.g. if assignment was in another function) this method call would be an error
instance.__dict__                                 # attributes and values of this class (excludes superclass attributes)
instance.__class__                                # has in turn another attributes such as __name__ and __bases__
instance.__bases__                                # contains names of all super classes

# abstract class
from abc import ABCMeta, abstractmethod
class AbstractClass(metaclass=ABCMeta):
    @abstractmethod
    def method():
        pass
abstract = AbstractClass()                        # error! classes with abstract method cannot be instantiated; define a subclass that defiend this method and instantiate that subclass

# operator overloading
class Person:
      def __init__(self, name, age):              #  constructor
          self.name = name
          self.age = age

      def __del__(self):                          # destructor
          pass

      def __add__(self, other):                   # used when object is used with + operator; could return any type of result
          pass

      def __sub__(self, other):                   # used with - operator
          pass

      def __getitem__(self, index):               # for index and slice reference expressions; also used as fallback iterator by repeatedly indexing from 0 until StopIteration occurs
          if isinstance(index, int):              # when instance[i] is invoked, i is passed as the second argument
              pass
          elif isinstance(slice):                 # when instance[i:j:k] is invoked, slice(i, j, k) is passed as the second argument
              pass

      def __setitem__(self, index, value):        # for index and slice assignments
          pass

      def __index__(self):                        # invoked when bin(instance), oct(instance) and hex(instance) is encountered
          return hash

      def set_name(name):
          self.name = name
          
      def get_name(self):
          return self.name

      def __repr__(self):
          return repr_representation              # returns a string that shows how the object was constructed

      def __str__(self):
          return string_representation            # string representation used by print(instance) and str(instance)

      def _method_name(self):                     # method name starting with _ are meant to be used within this class; overriding these is possible; use __ to avoid overriding
          ...

      def __method_name(self):                    # this method name is expanded to Person.__method_name(self) to avoid name clash when overriding this method
          ...

class Manager(Person):
      def get_name():
          Person.get_name(self, 'Mgr ' + name)    # calling parent's method

manager = Manager('John', 40)

